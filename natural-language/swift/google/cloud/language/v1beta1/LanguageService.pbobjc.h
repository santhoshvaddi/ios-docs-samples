// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/cloud/language/v1beta1/language_service.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers.h>
#else
 #import "GPBProtocolBuffers.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30002
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30002 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

CF_EXTERN_C_BEGIN

@class AnnotateTextRequest_Features;
@class DependencyEdge;
@class Document;
@class Entity;
@class EntityMention;
@class PartOfSpeech;
@class Sentence;
@class Sentiment;
@class TextSpan;
@class Token;

NS_ASSUME_NONNULL_BEGIN

#pragma mark - Enum EncodingType

/**
 * Represents the text encoding that the caller uses to process the output.
 * Providing an `EncodingType` is recommended because the API provides the
 * beginning offsets for various outputs, such as tokens and mentions, and
 * languages that natively use different text encodings may access offsets
 * differently.
 **/
typedef GPB_ENUM(EncodingType) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  EncodingType_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /**
   * If `EncodingType` is not specified, encoding-dependent information (such as
   * `begin_offset`) will be set at `-1`.
   **/
  EncodingType_None = 0,

  /**
   * Encoding-dependent information (such as `begin_offset`) is calculated based
   * on the UTF-8 encoding of the input. C++ and Go are examples of languages
   * that use this encoding natively.
   **/
  EncodingType_Utf8 = 1,

  /**
   * Encoding-dependent information (such as `begin_offset`) is calculated based
   * on the UTF-16 encoding of the input. Java and Javascript are examples of
   * languages that use this encoding natively.
   **/
  EncodingType_Utf16 = 2,

  /**
   * Encoding-dependent information (such as `begin_offset`) is calculated based
   * on the UTF-32 encoding of the input. Python is an example of a language
   * that uses this encoding natively.
   **/
  EncodingType_Utf32 = 3,
};

GPBEnumDescriptor *EncodingType_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL EncodingType_IsValidValue(int32_t value);

#pragma mark - Enum Document_Type

/** The document types enum. */
typedef GPB_ENUM(Document_Type) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  Document_Type_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** The content type is not specified. */
  Document_Type_TypeUnspecified = 0,

  /** Plain text */
  Document_Type_PlainText = 1,

  /** HTML */
  Document_Type_Html = 2,
};

GPBEnumDescriptor *Document_Type_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL Document_Type_IsValidValue(int32_t value);

#pragma mark - Enum Entity_Type

/** The type of the entity. */
typedef GPB_ENUM(Entity_Type) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  Entity_Type_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** Unknown */
  Entity_Type_Unknown = 0,

  /** Person */
  Entity_Type_Person = 1,

  /** Location */
  Entity_Type_Location = 2,

  /** Organization */
  Entity_Type_Organization = 3,

  /** Event */
  Entity_Type_Event = 4,

  /** Work of art */
  Entity_Type_WorkOfArt = 5,

  /** Consumer goods */
  Entity_Type_ConsumerGood = 6,

  /** Other types */
  Entity_Type_Other = 7,
};

GPBEnumDescriptor *Entity_Type_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL Entity_Type_IsValidValue(int32_t value);

#pragma mark - Enum PartOfSpeech_Tag

/** The part of speech tags enum. */
typedef GPB_ENUM(PartOfSpeech_Tag) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  PartOfSpeech_Tag_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** Unknown */
  PartOfSpeech_Tag_Unknown = 0,

  /** Adjective */
  PartOfSpeech_Tag_Adj = 1,

  /** Adposition (preposition and postposition) */
  PartOfSpeech_Tag_Adp = 2,

  /** Adverb */
  PartOfSpeech_Tag_Adv = 3,

  /** Conjunction */
  PartOfSpeech_Tag_Conj = 4,

  /** Determiner */
  PartOfSpeech_Tag_Det = 5,

  /** Noun (common and proper) */
  PartOfSpeech_Tag_Noun = 6,

  /** Cardinal number */
  PartOfSpeech_Tag_Num = 7,

  /** Pronoun */
  PartOfSpeech_Tag_Pron = 8,

  /** Particle or other function word */
  PartOfSpeech_Tag_Prt = 9,

  /** Punctuation */
  PartOfSpeech_Tag_Punct = 10,

  /** Verb (all tenses and modes) */
  PartOfSpeech_Tag_Verb = 11,

  /** Other: foreign words, typos, abbreviations */
  PartOfSpeech_Tag_X = 12,

  /** Affix */
  PartOfSpeech_Tag_Affix = 13,
};

GPBEnumDescriptor *PartOfSpeech_Tag_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PartOfSpeech_Tag_IsValidValue(int32_t value);

#pragma mark - Enum PartOfSpeech_Aspect

/** The characteristic of a verb that expresses time flow during an event. */
typedef GPB_ENUM(PartOfSpeech_Aspect) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  PartOfSpeech_Aspect_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** Aspect is not applicable in the analyzed language or is not predicted. */
  PartOfSpeech_Aspect_AspectUnknown = 0,

  /** Perfective */
  PartOfSpeech_Aspect_Perfective = 1,

  /** Imperfective */
  PartOfSpeech_Aspect_Imperfective = 2,

  /** Progressive */
  PartOfSpeech_Aspect_Progressive = 3,
};

GPBEnumDescriptor *PartOfSpeech_Aspect_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PartOfSpeech_Aspect_IsValidValue(int32_t value);

#pragma mark - Enum PartOfSpeech_Case

/**
 * The grammatical function performed by a noun or pronoun in a phrase,
 * clause, or sentence. In some languages, other parts of speech, such as
 * adjective and determiner, take case inflection in agreement with the noun.
 **/
typedef GPB_ENUM(PartOfSpeech_Case) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  PartOfSpeech_Case_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** Case is not applicable in the analyzed language or is not predicted. */
  PartOfSpeech_Case_CaseUnknown = 0,

  /** Accusative */
  PartOfSpeech_Case_Accusative = 1,

  /** Adverbial */
  PartOfSpeech_Case_Adverbial = 2,

  /** Complementive */
  PartOfSpeech_Case_Complementive = 3,

  /** Dative */
  PartOfSpeech_Case_Dative = 4,

  /** Genitive */
  PartOfSpeech_Case_Genitive = 5,

  /** Instrumental */
  PartOfSpeech_Case_Instrumental = 6,

  /** Locative */
  PartOfSpeech_Case_Locative = 7,

  /** Nominative */
  PartOfSpeech_Case_Nominative = 8,

  /** Oblique */
  PartOfSpeech_Case_Oblique = 9,

  /** Partitive */
  PartOfSpeech_Case_Partitive = 10,

  /** Prepositional */
  PartOfSpeech_Case_Prepositional = 11,

  /** Reflexive */
  PartOfSpeech_Case_ReflexiveCase = 12,

  /** Relative */
  PartOfSpeech_Case_RelativeCase = 13,

  /** Vocative */
  PartOfSpeech_Case_Vocative = 14,
};

GPBEnumDescriptor *PartOfSpeech_Case_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PartOfSpeech_Case_IsValidValue(int32_t value);

#pragma mark - Enum PartOfSpeech_Form

/**
 * Depending on the language, Form can be categorizing different forms of
 * verbs, adjectives, adverbs, etc. For example, categorizing inflected
 * endings of verbs and adjectives or distinguishing between short and long
 * forms of adjectives and participles
 **/
typedef GPB_ENUM(PartOfSpeech_Form) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  PartOfSpeech_Form_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** Form is not applicable in the analyzed language or is not predicted. */
  PartOfSpeech_Form_FormUnknown = 0,

  /** Adnomial */
  PartOfSpeech_Form_Adnomial = 1,

  /** Auxiliary */
  PartOfSpeech_Form_Auxiliary = 2,

  /** Complementizer */
  PartOfSpeech_Form_Complementizer = 3,

  /** Final ending */
  PartOfSpeech_Form_FinalEnding = 4,

  /** Gerund */
  PartOfSpeech_Form_Gerund = 5,

  /** Realis */
  PartOfSpeech_Form_Realis = 6,

  /** Irrealis */
  PartOfSpeech_Form_Irrealis = 7,

  /** Short form */
  PartOfSpeech_Form_Short = 8,

  /** Long form */
  PartOfSpeech_Form_Long = 9,

  /** Order form */
  PartOfSpeech_Form_Order = 10,

  /** Specific form */
  PartOfSpeech_Form_Specific = 11,
};

GPBEnumDescriptor *PartOfSpeech_Form_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PartOfSpeech_Form_IsValidValue(int32_t value);

#pragma mark - Enum PartOfSpeech_Gender

/** Gender classes of nouns reflected in the behaviour of associated words. */
typedef GPB_ENUM(PartOfSpeech_Gender) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  PartOfSpeech_Gender_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** Gender is not applicable in the analyzed language or is not predicted. */
  PartOfSpeech_Gender_GenderUnknown = 0,

  /** Feminine */
  PartOfSpeech_Gender_Feminine = 1,

  /** Masculine */
  PartOfSpeech_Gender_Masculine = 2,

  /** Neuter */
  PartOfSpeech_Gender_Neuter = 3,
};

GPBEnumDescriptor *PartOfSpeech_Gender_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PartOfSpeech_Gender_IsValidValue(int32_t value);

#pragma mark - Enum PartOfSpeech_Mood

/** The grammatical feature of verbs, used for showing modality and attitude. */
typedef GPB_ENUM(PartOfSpeech_Mood) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  PartOfSpeech_Mood_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** Mood is not applicable in the analyzed language or is not predicted. */
  PartOfSpeech_Mood_MoodUnknown = 0,

  /** Conditional */
  PartOfSpeech_Mood_ConditionalMood = 1,

  /** Imperative */
  PartOfSpeech_Mood_Imperative = 2,

  /** Indicative */
  PartOfSpeech_Mood_Indicative = 3,

  /** Interrogative */
  PartOfSpeech_Mood_Interrogative = 4,

  /** Jussive */
  PartOfSpeech_Mood_Jussive = 5,

  /** Subjunctive */
  PartOfSpeech_Mood_Subjunctive = 6,
};

GPBEnumDescriptor *PartOfSpeech_Mood_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PartOfSpeech_Mood_IsValidValue(int32_t value);

#pragma mark - Enum PartOfSpeech_Number

/** Count distinctions. */
typedef GPB_ENUM(PartOfSpeech_Number) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  PartOfSpeech_Number_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** Number is not applicable in the analyzed language or is not predicted. */
  PartOfSpeech_Number_NumberUnknown = 0,

  /** Singular */
  PartOfSpeech_Number_Singular = 1,

  /** Plural */
  PartOfSpeech_Number_Plural = 2,

  /** Dual */
  PartOfSpeech_Number_Dual = 3,
};

GPBEnumDescriptor *PartOfSpeech_Number_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PartOfSpeech_Number_IsValidValue(int32_t value);

#pragma mark - Enum PartOfSpeech_Person

/** The distinction between the speaker, second person, third person, etc. */
typedef GPB_ENUM(PartOfSpeech_Person) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  PartOfSpeech_Person_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** Person is not applicable in the analyzed language or is not predicted. */
  PartOfSpeech_Person_PersonUnknown = 0,

  /** First */
  PartOfSpeech_Person_First = 1,

  /** Second */
  PartOfSpeech_Person_Second = 2,

  /** Third */
  PartOfSpeech_Person_Third = 3,

  /** Reflexive */
  PartOfSpeech_Person_ReflexivePerson = 4,
};

GPBEnumDescriptor *PartOfSpeech_Person_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PartOfSpeech_Person_IsValidValue(int32_t value);

#pragma mark - Enum PartOfSpeech_Proper

/** This category shows if the token is part of a proper name. */
typedef GPB_ENUM(PartOfSpeech_Proper) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  PartOfSpeech_Proper_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** Proper is not applicable in the analyzed language or is not predicted. */
  PartOfSpeech_Proper_ProperUnknown = 0,

  /** Proper */
  PartOfSpeech_Proper_Proper = 1,

  /** Not proper */
  PartOfSpeech_Proper_NotProper = 2,
};

GPBEnumDescriptor *PartOfSpeech_Proper_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PartOfSpeech_Proper_IsValidValue(int32_t value);

#pragma mark - Enum PartOfSpeech_Reciprocity

/** Reciprocal features of a pronoun. */
typedef GPB_ENUM(PartOfSpeech_Reciprocity) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  PartOfSpeech_Reciprocity_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /**
   * Reciprocity is not applicable in the analyzed language or is not
   * predicted.
   **/
  PartOfSpeech_Reciprocity_ReciprocityUnknown = 0,

  /** Reciprocal */
  PartOfSpeech_Reciprocity_Reciprocal = 1,

  /** Non-reciprocal */
  PartOfSpeech_Reciprocity_NonReciprocal = 2,
};

GPBEnumDescriptor *PartOfSpeech_Reciprocity_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PartOfSpeech_Reciprocity_IsValidValue(int32_t value);

#pragma mark - Enum PartOfSpeech_Tense

/** Time reference. */
typedef GPB_ENUM(PartOfSpeech_Tense) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  PartOfSpeech_Tense_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** Tense is not applicable in the analyzed language or is not predicted. */
  PartOfSpeech_Tense_TenseUnknown = 0,

  /** Conditional */
  PartOfSpeech_Tense_ConditionalTense = 1,

  /** Future */
  PartOfSpeech_Tense_Future = 2,

  /** Past */
  PartOfSpeech_Tense_Past = 3,

  /** Present */
  PartOfSpeech_Tense_Present = 4,

  /** Imperfect */
  PartOfSpeech_Tense_Imperfect = 5,

  /** Pluperfect */
  PartOfSpeech_Tense_Pluperfect = 6,
};

GPBEnumDescriptor *PartOfSpeech_Tense_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PartOfSpeech_Tense_IsValidValue(int32_t value);

#pragma mark - Enum PartOfSpeech_Voice

/**
 * The relationship between the action that a verb expresses and the
 * participants identified by its arguments.
 **/
typedef GPB_ENUM(PartOfSpeech_Voice) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  PartOfSpeech_Voice_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** Voice is not applicable in the analyzed language or is not predicted. */
  PartOfSpeech_Voice_VoiceUnknown = 0,

  /** Active */
  PartOfSpeech_Voice_Active = 1,

  /** Causative */
  PartOfSpeech_Voice_Causative = 2,

  /** Passive */
  PartOfSpeech_Voice_Passive = 3,
};

GPBEnumDescriptor *PartOfSpeech_Voice_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL PartOfSpeech_Voice_IsValidValue(int32_t value);

#pragma mark - Enum DependencyEdge_Label

/** The parse label enum for the token. */
typedef GPB_ENUM(DependencyEdge_Label) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  DependencyEdge_Label_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** Unknown */
  DependencyEdge_Label_Unknown = 0,

  /** Abbreviation modifier */
  DependencyEdge_Label_Abbrev = 1,

  /** Adjectival complement */
  DependencyEdge_Label_Acomp = 2,

  /** Adverbial clause modifier */
  DependencyEdge_Label_Advcl = 3,

  /** Adverbial modifier */
  DependencyEdge_Label_Advmod = 4,

  /** Adjectival modifier of an NP */
  DependencyEdge_Label_Amod = 5,

  /** Appositional modifier of an NP */
  DependencyEdge_Label_Appos = 6,

  /** Attribute dependent of a copular verb */
  DependencyEdge_Label_Attr = 7,

  /** Auxiliary (non-main) verb */
  DependencyEdge_Label_Aux = 8,

  /** Passive auxiliary */
  DependencyEdge_Label_Auxpass = 9,

  /** Coordinating conjunction */
  DependencyEdge_Label_Cc = 10,

  /** Clausal complement of a verb or adjective */
  DependencyEdge_Label_Ccomp = 11,

  /** Conjunct */
  DependencyEdge_Label_Conj = 12,

  /** Clausal subject */
  DependencyEdge_Label_Csubj = 13,

  /** Clausal passive subject */
  DependencyEdge_Label_Csubjpass = 14,

  /** Dependency (unable to determine) */
  DependencyEdge_Label_Dep = 15,

  /** Determiner */
  DependencyEdge_Label_Det = 16,

  /** Discourse */
  DependencyEdge_Label_Discourse = 17,

  /** Direct object */
  DependencyEdge_Label_Dobj = 18,

  /** Expletive */
  DependencyEdge_Label_Expl = 19,

  /** Goes with (part of a word in a text not well edited) */
  DependencyEdge_Label_Goeswith = 20,

  /** Indirect object */
  DependencyEdge_Label_Iobj = 21,

  /** Marker (word introducing a subordinate clause) */
  DependencyEdge_Label_Mark = 22,

  /** Multi-word expression */
  DependencyEdge_Label_Mwe = 23,

  /** Multi-word verbal expression */
  DependencyEdge_Label_Mwv = 24,

  /** Negation modifier */
  DependencyEdge_Label_Neg = 25,

  /** Noun compound modifier */
  DependencyEdge_Label_Nn = 26,

  /** Noun phrase used as an adverbial modifier */
  DependencyEdge_Label_Npadvmod = 27,

  /** Nominal subject */
  DependencyEdge_Label_Nsubj = 28,

  /** Passive nominal subject */
  DependencyEdge_Label_Nsubjpass = 29,

  /** Numeric modifier of a noun */
  DependencyEdge_Label_Num = 30,

  /** Element of compound number */
  DependencyEdge_Label_Number = 31,

  /** Punctuation mark */
  DependencyEdge_Label_P = 32,

  /** Parataxis relation */
  DependencyEdge_Label_Parataxis = 33,

  /** Participial modifier */
  DependencyEdge_Label_Partmod = 34,

  /** The complement of a preposition is a clause */
  DependencyEdge_Label_Pcomp = 35,

  /** Object of a preposition */
  DependencyEdge_Label_Pobj = 36,

  /** Possession modifier */
  DependencyEdge_Label_Poss = 37,

  /** Postverbal negative particle */
  DependencyEdge_Label_Postneg = 38,

  /** Predicate complement */
  DependencyEdge_Label_Precomp = 39,

  /** Preconjunt */
  DependencyEdge_Label_Preconj = 40,

  /** Predeterminer */
  DependencyEdge_Label_Predet = 41,

  /** Prefix */
  DependencyEdge_Label_Pref = 42,

  /** Prepositional modifier */
  DependencyEdge_Label_Prep = 43,

  /** The relationship between a verb and verbal morpheme */
  DependencyEdge_Label_Pronl = 44,

  /** Particle */
  DependencyEdge_Label_Prt = 45,

  /** Associative or possessive marker */
  DependencyEdge_Label_Ps = 46,

  /** Quantifier phrase modifier */
  DependencyEdge_Label_Quantmod = 47,

  /** Relative clause modifier */
  DependencyEdge_Label_Rcmod = 48,

  /** Complementizer in relative clause */
  DependencyEdge_Label_Rcmodrel = 49,

  /** Ellipsis without a preceding predicate */
  DependencyEdge_Label_Rdrop = 50,

  /** Referent */
  DependencyEdge_Label_Ref = 51,

  /** Remnant */
  DependencyEdge_Label_Remnant = 52,

  /** Reparandum */
  DependencyEdge_Label_Reparandum = 53,

  /** Root */
  DependencyEdge_Label_Root = 54,

  /** Suffix specifying a unit of number */
  DependencyEdge_Label_Snum = 55,

  /** Suffix */
  DependencyEdge_Label_Suff = 56,

  /** Temporal modifier */
  DependencyEdge_Label_Tmod = 57,

  /** Topic marker */
  DependencyEdge_Label_Topic = 58,

  /** Clause headed by an infinite form of the verb that modifies a noun */
  DependencyEdge_Label_Vmod = 59,

  /** Vocative */
  DependencyEdge_Label_Vocative = 60,

  /** Open clausal complement */
  DependencyEdge_Label_Xcomp = 61,

  /** Name suffix */
  DependencyEdge_Label_Suffix = 62,

  /** Name title */
  DependencyEdge_Label_Title = 63,

  /** Adverbial phrase modifier */
  DependencyEdge_Label_Advphmod = 64,

  /** Causative auxiliary */
  DependencyEdge_Label_Auxcaus = 65,

  /** Helper auxiliary */
  DependencyEdge_Label_Auxvv = 66,

  /** Rentaishi (Prenominal modifier) */
  DependencyEdge_Label_Dtmod = 67,

  /** Foreign words */
  DependencyEdge_Label_Foreign = 68,

  /** Keyword */
  DependencyEdge_Label_Kw = 69,

  /** List for chains of comparable items */
  DependencyEdge_Label_List = 70,

  /** Nominalized clause */
  DependencyEdge_Label_Nomc = 71,

  /** Nominalized clausal subject */
  DependencyEdge_Label_Nomcsubj = 72,

  /** Nominalized clausal passive */
  DependencyEdge_Label_Nomcsubjpass = 73,

  /** Compound of numeric modifier */
  DependencyEdge_Label_Numc = 74,

  /** Copula */
  DependencyEdge_Label_Cop = 75,

  /** Dislocated relation (for fronted/topicalized elements) */
  DependencyEdge_Label_Dislocated = 76,
};

GPBEnumDescriptor *DependencyEdge_Label_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL DependencyEdge_Label_IsValidValue(int32_t value);

#pragma mark - Enum EntityMention_Type

/** The supported types of mentions. */
typedef GPB_ENUM(EntityMention_Type) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  EntityMention_Type_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** Unknown */
  EntityMention_Type_TypeUnknown = 0,

  /** Proper name */
  EntityMention_Type_Proper = 1,

  /** Common noun (or noun compound) */
  EntityMention_Type_Common = 2,
};

GPBEnumDescriptor *EntityMention_Type_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL EntityMention_Type_IsValidValue(int32_t value);

#pragma mark - LanguageServiceRoot

/**
 * Exposes the extension registry for this file.
 *
 * The base class provides:
 * @code
 *   + (GPBExtensionRegistry *)extensionRegistry;
 * @endcode
 * which is a @c GPBExtensionRegistry that includes all the extensions defined by
 * this file and all files that it depends on.
 **/
@interface LanguageServiceRoot : GPBRootObject
@end

#pragma mark - Document

typedef GPB_ENUM(Document_FieldNumber) {
  Document_FieldNumber_Type = 1,
  Document_FieldNumber_Content = 2,
  Document_FieldNumber_GcsContentUri = 3,
  Document_FieldNumber_Language = 4,
};

typedef GPB_ENUM(Document_Source_OneOfCase) {
  Document_Source_OneOfCase_GPBUnsetOneOfCase = 0,
  Document_Source_OneOfCase_Content = 2,
  Document_Source_OneOfCase_GcsContentUri = 3,
};

/**
 * ################################################################ #
 *
 * Represents the input to API methods.
 **/
@interface Document : GPBMessage

/**
 * Required. If the type is not set or is `TYPE_UNSPECIFIED`,
 * returns an `INVALID_ARGUMENT` error.
 **/
@property(nonatomic, readwrite) Document_Type type;

/**
 * The source of the document: a string containing the content or a
 * Google Cloud Storage URI.
 **/
@property(nonatomic, readonly) Document_Source_OneOfCase sourceOneOfCase;

/** The content of the input in string format. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *content;

/**
 * The Google Cloud Storage URI where the file content is located.
 * This URI must be of the form: gs://bucket_name/object_name. For more
 * details, see https://cloud.google.com/storage/docs/reference-uris.
 * NOTE: Cloud Storage object versioning is not supported.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *gcsContentUri;

/**
 * The language of the document (if not specified, the language is
 * automatically detected). Both ISO and BCP-47 language codes are
 * accepted.<br>
 * [Language
 * Support](https://cloud.google.com/natural-language/docs/languages) lists
 * currently supported languages for each API method. If the language (either
 * specified by the caller or automatically detected) is not supported by the
 * called API method, an `INVALID_ARGUMENT` error is returned.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *language;

@end

/**
 * Fetches the raw value of a @c Document's @c type property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t Document_Type_RawValue(Document *message);
/**
 * Sets the raw value of an @c Document's @c type property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetDocument_Type_RawValue(Document *message, int32_t value);

/**
 * Clears whatever value was set for the oneof 'source'.
 **/
void Document_ClearSourceOneOfCase(Document *message);

#pragma mark - Sentence

typedef GPB_ENUM(Sentence_FieldNumber) {
  Sentence_FieldNumber_Text = 1,
  Sentence_FieldNumber_Sentiment = 2,
};

/**
 * Represents a sentence in the input document.
 **/
@interface Sentence : GPBMessage

/** The sentence text. */
@property(nonatomic, readwrite, strong, null_resettable) TextSpan *text;
/** Test to see if @c text has been set. */
@property(nonatomic, readwrite) BOOL hasText;

/**
 * For calls to [AnalyzeSentiment][] or if
 * [AnnotateTextRequest.Features.extract_document_sentiment][google.cloud.language.v1beta1.AnnotateTextRequest.Features.extract_document_sentiment]
 * is set to true, this field will contain the sentiment for the sentence.
 **/
@property(nonatomic, readwrite, strong, null_resettable) Sentiment *sentiment;
/** Test to see if @c sentiment has been set. */
@property(nonatomic, readwrite) BOOL hasSentiment;

@end

#pragma mark - Entity

typedef GPB_ENUM(Entity_FieldNumber) {
  Entity_FieldNumber_Name = 1,
  Entity_FieldNumber_Type = 2,
  Entity_FieldNumber_Metadata = 3,
  Entity_FieldNumber_Salience = 4,
  Entity_FieldNumber_MentionsArray = 5,
};

/**
 * Represents a phrase in the text that is a known entity, such as
 * a person, an organization, or location. The API associates information, such
 * as salience and mentions, with entities.
 **/
@interface Entity : GPBMessage

/** The representative name for the entity. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *name;

/** The entity type. */
@property(nonatomic, readwrite) Entity_Type type;

/**
 * Metadata associated with the entity.
 *
 * Currently, Wikipedia URLs and Knowledge Graph MIDs are provided, if
 * available. The associated keys are "wikipedia_url" and "mid", respectively.
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableDictionary<NSString*, NSString*> *metadata;
/** The number of items in @c metadata without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger metadata_Count;

/**
 * The salience score associated with the entity in the [0, 1.0] range.
 *
 * The salience score for an entity provides information about the
 * importance or centrality of that entity to the entire document text.
 * Scores closer to 0 are less salient, while scores closer to 1.0 are highly
 * salient.
 **/
@property(nonatomic, readwrite) float salience;

/**
 * The mentions of this entity in the input document. The API currently
 * supports proper noun mentions.
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<EntityMention*> *mentionsArray;
/** The number of items in @c mentionsArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger mentionsArray_Count;

@end

/**
 * Fetches the raw value of a @c Entity's @c type property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t Entity_Type_RawValue(Entity *message);
/**
 * Sets the raw value of an @c Entity's @c type property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetEntity_Type_RawValue(Entity *message, int32_t value);

#pragma mark - Token

typedef GPB_ENUM(Token_FieldNumber) {
  Token_FieldNumber_Text = 1,
  Token_FieldNumber_PartOfSpeech = 2,
  Token_FieldNumber_DependencyEdge = 3,
  Token_FieldNumber_Lemma = 4,
};

/**
 * Represents the smallest syntactic building block of the text.
 **/
@interface Token : GPBMessage

/** The token text. */
@property(nonatomic, readwrite, strong, null_resettable) TextSpan *text;
/** Test to see if @c text has been set. */
@property(nonatomic, readwrite) BOOL hasText;

/** Parts of speech tag for this token. */
@property(nonatomic, readwrite, strong, null_resettable) PartOfSpeech *partOfSpeech;
/** Test to see if @c partOfSpeech has been set. */
@property(nonatomic, readwrite) BOOL hasPartOfSpeech;

/** Dependency tree parse for this token. */
@property(nonatomic, readwrite, strong, null_resettable) DependencyEdge *dependencyEdge;
/** Test to see if @c dependencyEdge has been set. */
@property(nonatomic, readwrite) BOOL hasDependencyEdge;

/** [Lemma](https://en.wikipedia.org/wiki/Lemma_%28morphology%29) of the token. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *lemma;

@end

#pragma mark - Sentiment

typedef GPB_ENUM(Sentiment_FieldNumber) {
  Sentiment_FieldNumber_Polarity = 1,
  Sentiment_FieldNumber_Magnitude = 2,
  Sentiment_FieldNumber_Score = 3,
};

/**
 * Represents the feeling associated with the entire text or entities in
 * the text.
 **/
@interface Sentiment : GPBMessage

/**
 * DEPRECATED FIELD - This field is being deprecated in
 * favor of score. Please refer to our documentation at
 * https://cloud.google.com/natural-language/docs for more information.
 **/
@property(nonatomic, readwrite) float polarity;

/**
 * A non-negative number in the [0, +inf) range, which represents
 * the absolute magnitude of sentiment regardless of score (positive or
 * negative).
 **/
@property(nonatomic, readwrite) float magnitude;

/**
 * Sentiment score between -1.0 (negative sentiment) and 1.0
 * (positive sentiment).
 **/
@property(nonatomic, readwrite) float score;

@end

#pragma mark - PartOfSpeech

typedef GPB_ENUM(PartOfSpeech_FieldNumber) {
  PartOfSpeech_FieldNumber_Tag = 1,
  PartOfSpeech_FieldNumber_Aspect = 2,
  PartOfSpeech_FieldNumber_Case_p = 3,
  PartOfSpeech_FieldNumber_Form = 4,
  PartOfSpeech_FieldNumber_Gender = 5,
  PartOfSpeech_FieldNumber_Mood = 6,
  PartOfSpeech_FieldNumber_Number = 7,
  PartOfSpeech_FieldNumber_Person = 8,
  PartOfSpeech_FieldNumber_Proper = 9,
  PartOfSpeech_FieldNumber_Reciprocity = 10,
  PartOfSpeech_FieldNumber_Tense = 11,
  PartOfSpeech_FieldNumber_Voice = 12,
};

/**
 * Represents part of speech information for a token.
 **/
@interface PartOfSpeech : GPBMessage

/** The part of speech tag. */
@property(nonatomic, readwrite) PartOfSpeech_Tag tag;

/** The grammatical aspect. */
@property(nonatomic, readwrite) PartOfSpeech_Aspect aspect;

/** The grammatical case. */
@property(nonatomic, readwrite) PartOfSpeech_Case case_p;

/** The grammatical form. */
@property(nonatomic, readwrite) PartOfSpeech_Form form;

/** The grammatical gender. */
@property(nonatomic, readwrite) PartOfSpeech_Gender gender;

/** The grammatical mood. */
@property(nonatomic, readwrite) PartOfSpeech_Mood mood;

/** The grammatical number. */
@property(nonatomic, readwrite) PartOfSpeech_Number number;

/** The grammatical person. */
@property(nonatomic, readwrite) PartOfSpeech_Person person;

/** The grammatical properness. */
@property(nonatomic, readwrite) PartOfSpeech_Proper proper;

/** The grammatical reciprocity. */
@property(nonatomic, readwrite) PartOfSpeech_Reciprocity reciprocity;

/** The grammatical tense. */
@property(nonatomic, readwrite) PartOfSpeech_Tense tense;

/** The grammatical voice. */
@property(nonatomic, readwrite) PartOfSpeech_Voice voice;

@end

/**
 * Fetches the raw value of a @c PartOfSpeech's @c tag property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t PartOfSpeech_Tag_RawValue(PartOfSpeech *message);
/**
 * Sets the raw value of an @c PartOfSpeech's @c tag property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetPartOfSpeech_Tag_RawValue(PartOfSpeech *message, int32_t value);

/**
 * Fetches the raw value of a @c PartOfSpeech's @c aspect property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t PartOfSpeech_Aspect_RawValue(PartOfSpeech *message);
/**
 * Sets the raw value of an @c PartOfSpeech's @c aspect property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetPartOfSpeech_Aspect_RawValue(PartOfSpeech *message, int32_t value);

/**
 * Fetches the raw value of a @c PartOfSpeech's @c case_p property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t PartOfSpeech_Case_p_RawValue(PartOfSpeech *message);
/**
 * Sets the raw value of an @c PartOfSpeech's @c case_p property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetPartOfSpeech_Case_p_RawValue(PartOfSpeech *message, int32_t value);

/**
 * Fetches the raw value of a @c PartOfSpeech's @c form property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t PartOfSpeech_Form_RawValue(PartOfSpeech *message);
/**
 * Sets the raw value of an @c PartOfSpeech's @c form property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetPartOfSpeech_Form_RawValue(PartOfSpeech *message, int32_t value);

/**
 * Fetches the raw value of a @c PartOfSpeech's @c gender property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t PartOfSpeech_Gender_RawValue(PartOfSpeech *message);
/**
 * Sets the raw value of an @c PartOfSpeech's @c gender property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetPartOfSpeech_Gender_RawValue(PartOfSpeech *message, int32_t value);

/**
 * Fetches the raw value of a @c PartOfSpeech's @c mood property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t PartOfSpeech_Mood_RawValue(PartOfSpeech *message);
/**
 * Sets the raw value of an @c PartOfSpeech's @c mood property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetPartOfSpeech_Mood_RawValue(PartOfSpeech *message, int32_t value);

/**
 * Fetches the raw value of a @c PartOfSpeech's @c number property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t PartOfSpeech_Number_RawValue(PartOfSpeech *message);
/**
 * Sets the raw value of an @c PartOfSpeech's @c number property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetPartOfSpeech_Number_RawValue(PartOfSpeech *message, int32_t value);

/**
 * Fetches the raw value of a @c PartOfSpeech's @c person property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t PartOfSpeech_Person_RawValue(PartOfSpeech *message);
/**
 * Sets the raw value of an @c PartOfSpeech's @c person property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetPartOfSpeech_Person_RawValue(PartOfSpeech *message, int32_t value);

/**
 * Fetches the raw value of a @c PartOfSpeech's @c proper property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t PartOfSpeech_Proper_RawValue(PartOfSpeech *message);
/**
 * Sets the raw value of an @c PartOfSpeech's @c proper property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetPartOfSpeech_Proper_RawValue(PartOfSpeech *message, int32_t value);

/**
 * Fetches the raw value of a @c PartOfSpeech's @c reciprocity property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t PartOfSpeech_Reciprocity_RawValue(PartOfSpeech *message);
/**
 * Sets the raw value of an @c PartOfSpeech's @c reciprocity property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetPartOfSpeech_Reciprocity_RawValue(PartOfSpeech *message, int32_t value);

/**
 * Fetches the raw value of a @c PartOfSpeech's @c tense property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t PartOfSpeech_Tense_RawValue(PartOfSpeech *message);
/**
 * Sets the raw value of an @c PartOfSpeech's @c tense property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetPartOfSpeech_Tense_RawValue(PartOfSpeech *message, int32_t value);

/**
 * Fetches the raw value of a @c PartOfSpeech's @c voice property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t PartOfSpeech_Voice_RawValue(PartOfSpeech *message);
/**
 * Sets the raw value of an @c PartOfSpeech's @c voice property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetPartOfSpeech_Voice_RawValue(PartOfSpeech *message, int32_t value);

#pragma mark - DependencyEdge

typedef GPB_ENUM(DependencyEdge_FieldNumber) {
  DependencyEdge_FieldNumber_HeadTokenIndex = 1,
  DependencyEdge_FieldNumber_Label = 2,
};

/**
 * Represents dependency parse tree information for a token.
 **/
@interface DependencyEdge : GPBMessage

/**
 * Represents the head of this token in the dependency tree.
 * This is the index of the token which has an arc going to this token.
 * The index is the position of the token in the array of tokens returned
 * by the API method. If this token is a root token, then the
 * `head_token_index` is its own index.
 **/
@property(nonatomic, readwrite) int32_t headTokenIndex;

/** The parse label for the token. */
@property(nonatomic, readwrite) DependencyEdge_Label label;

@end

/**
 * Fetches the raw value of a @c DependencyEdge's @c label property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t DependencyEdge_Label_RawValue(DependencyEdge *message);
/**
 * Sets the raw value of an @c DependencyEdge's @c label property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetDependencyEdge_Label_RawValue(DependencyEdge *message, int32_t value);

#pragma mark - EntityMention

typedef GPB_ENUM(EntityMention_FieldNumber) {
  EntityMention_FieldNumber_Text = 1,
  EntityMention_FieldNumber_Type = 2,
};

/**
 * Represents a mention for an entity in the text. Currently, proper noun
 * mentions are supported.
 **/
@interface EntityMention : GPBMessage

/** The mention text. */
@property(nonatomic, readwrite, strong, null_resettable) TextSpan *text;
/** Test to see if @c text has been set. */
@property(nonatomic, readwrite) BOOL hasText;

/** The type of the entity mention. */
@property(nonatomic, readwrite) EntityMention_Type type;

@end

/**
 * Fetches the raw value of a @c EntityMention's @c type property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t EntityMention_Type_RawValue(EntityMention *message);
/**
 * Sets the raw value of an @c EntityMention's @c type property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetEntityMention_Type_RawValue(EntityMention *message, int32_t value);

#pragma mark - TextSpan

typedef GPB_ENUM(TextSpan_FieldNumber) {
  TextSpan_FieldNumber_Content = 1,
  TextSpan_FieldNumber_BeginOffset = 2,
};

/**
 * Represents an output piece of text.
 **/
@interface TextSpan : GPBMessage

/** The content of the output text. */
@property(nonatomic, readwrite, copy, null_resettable) NSString *content;

/**
 * The API calculates the beginning offset of the content in the original
 * document according to the
 * [EncodingType][google.cloud.language.v1beta1.EncodingType] specified in the
 * API request.
 **/
@property(nonatomic, readwrite) int32_t beginOffset;

@end

#pragma mark - AnalyzeSentimentRequest

typedef GPB_ENUM(AnalyzeSentimentRequest_FieldNumber) {
  AnalyzeSentimentRequest_FieldNumber_Document = 1,
  AnalyzeSentimentRequest_FieldNumber_EncodingType = 2,
};

/**
 * The sentiment analysis request message.
 **/
@interface AnalyzeSentimentRequest : GPBMessage

/** Input document. */
@property(nonatomic, readwrite, strong, null_resettable) Document *document;
/** Test to see if @c document has been set. */
@property(nonatomic, readwrite) BOOL hasDocument;

/**
 * The encoding type used by the API to calculate sentence offsets for the
 * sentence sentiment.
 **/
@property(nonatomic, readwrite) EncodingType encodingType;

@end

/**
 * Fetches the raw value of a @c AnalyzeSentimentRequest's @c encodingType property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t AnalyzeSentimentRequest_EncodingType_RawValue(AnalyzeSentimentRequest *message);
/**
 * Sets the raw value of an @c AnalyzeSentimentRequest's @c encodingType property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetAnalyzeSentimentRequest_EncodingType_RawValue(AnalyzeSentimentRequest *message, int32_t value);

#pragma mark - AnalyzeSentimentResponse

typedef GPB_ENUM(AnalyzeSentimentResponse_FieldNumber) {
  AnalyzeSentimentResponse_FieldNumber_DocumentSentiment = 1,
  AnalyzeSentimentResponse_FieldNumber_Language = 2,
  AnalyzeSentimentResponse_FieldNumber_SentencesArray = 3,
};

/**
 * The sentiment analysis response message.
 **/
@interface AnalyzeSentimentResponse : GPBMessage

/** The overall sentiment of the input document. */
@property(nonatomic, readwrite, strong, null_resettable) Sentiment *documentSentiment;
/** Test to see if @c documentSentiment has been set. */
@property(nonatomic, readwrite) BOOL hasDocumentSentiment;

/**
 * The language of the text, which will be the same as the language specified
 * in the request or, if not specified, the automatically-detected language.
 * See [Document.language][google.cloud.language.v1beta1.Document.language]
 * field for more details.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *language;

/** The sentiment for all the sentences in the document. */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<Sentence*> *sentencesArray;
/** The number of items in @c sentencesArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger sentencesArray_Count;

@end

#pragma mark - AnalyzeEntitiesRequest

typedef GPB_ENUM(AnalyzeEntitiesRequest_FieldNumber) {
  AnalyzeEntitiesRequest_FieldNumber_Document = 1,
  AnalyzeEntitiesRequest_FieldNumber_EncodingType = 2,
};

/**
 * The entity analysis request message.
 **/
@interface AnalyzeEntitiesRequest : GPBMessage

/** Input document. */
@property(nonatomic, readwrite, strong, null_resettable) Document *document;
/** Test to see if @c document has been set. */
@property(nonatomic, readwrite) BOOL hasDocument;

/** The encoding type used by the API to calculate offsets. */
@property(nonatomic, readwrite) EncodingType encodingType;

@end

/**
 * Fetches the raw value of a @c AnalyzeEntitiesRequest's @c encodingType property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t AnalyzeEntitiesRequest_EncodingType_RawValue(AnalyzeEntitiesRequest *message);
/**
 * Sets the raw value of an @c AnalyzeEntitiesRequest's @c encodingType property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetAnalyzeEntitiesRequest_EncodingType_RawValue(AnalyzeEntitiesRequest *message, int32_t value);

#pragma mark - AnalyzeEntitiesResponse

typedef GPB_ENUM(AnalyzeEntitiesResponse_FieldNumber) {
  AnalyzeEntitiesResponse_FieldNumber_EntitiesArray = 1,
  AnalyzeEntitiesResponse_FieldNumber_Language = 2,
};

/**
 * The entity analysis response message.
 **/
@interface AnalyzeEntitiesResponse : GPBMessage

/** The recognized entities in the input document. */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<Entity*> *entitiesArray;
/** The number of items in @c entitiesArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger entitiesArray_Count;

/**
 * The language of the text, which will be the same as the language specified
 * in the request or, if not specified, the automatically-detected language.
 * See [Document.language][google.cloud.language.v1beta1.Document.language]
 * field for more details.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *language;

@end

#pragma mark - AnalyzeSyntaxRequest

typedef GPB_ENUM(AnalyzeSyntaxRequest_FieldNumber) {
  AnalyzeSyntaxRequest_FieldNumber_Document = 1,
  AnalyzeSyntaxRequest_FieldNumber_EncodingType = 2,
};

/**
 * The syntax analysis request message.
 **/
@interface AnalyzeSyntaxRequest : GPBMessage

/** Input document. */
@property(nonatomic, readwrite, strong, null_resettable) Document *document;
/** Test to see if @c document has been set. */
@property(nonatomic, readwrite) BOOL hasDocument;

/** The encoding type used by the API to calculate offsets. */
@property(nonatomic, readwrite) EncodingType encodingType;

@end

/**
 * Fetches the raw value of a @c AnalyzeSyntaxRequest's @c encodingType property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t AnalyzeSyntaxRequest_EncodingType_RawValue(AnalyzeSyntaxRequest *message);
/**
 * Sets the raw value of an @c AnalyzeSyntaxRequest's @c encodingType property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetAnalyzeSyntaxRequest_EncodingType_RawValue(AnalyzeSyntaxRequest *message, int32_t value);

#pragma mark - AnalyzeSyntaxResponse

typedef GPB_ENUM(AnalyzeSyntaxResponse_FieldNumber) {
  AnalyzeSyntaxResponse_FieldNumber_SentencesArray = 1,
  AnalyzeSyntaxResponse_FieldNumber_TokensArray = 2,
  AnalyzeSyntaxResponse_FieldNumber_Language = 3,
};

/**
 * The syntax analysis response message.
 **/
@interface AnalyzeSyntaxResponse : GPBMessage

/** Sentences in the input document. */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<Sentence*> *sentencesArray;
/** The number of items in @c sentencesArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger sentencesArray_Count;

/** Tokens, along with their syntactic information, in the input document. */
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<Token*> *tokensArray;
/** The number of items in @c tokensArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger tokensArray_Count;

/**
 * The language of the text, which will be the same as the language specified
 * in the request or, if not specified, the automatically-detected language.
 * See [Document.language][google.cloud.language.v1beta1.Document.language]
 * field for more details.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *language;

@end

#pragma mark - AnnotateTextRequest

typedef GPB_ENUM(AnnotateTextRequest_FieldNumber) {
  AnnotateTextRequest_FieldNumber_Document = 1,
  AnnotateTextRequest_FieldNumber_Features = 2,
  AnnotateTextRequest_FieldNumber_EncodingType = 3,
};

/**
 * The request message for the text annotation API, which can perform multiple
 * analysis types (sentiment, entities, and syntax) in one call.
 **/
@interface AnnotateTextRequest : GPBMessage

/** Input document. */
@property(nonatomic, readwrite, strong, null_resettable) Document *document;
/** Test to see if @c document has been set. */
@property(nonatomic, readwrite) BOOL hasDocument;

/** The enabled features. */
@property(nonatomic, readwrite, strong, null_resettable) AnnotateTextRequest_Features *features;
/** Test to see if @c features has been set. */
@property(nonatomic, readwrite) BOOL hasFeatures;

/** The encoding type used by the API to calculate offsets. */
@property(nonatomic, readwrite) EncodingType encodingType;

@end

/**
 * Fetches the raw value of a @c AnnotateTextRequest's @c encodingType property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t AnnotateTextRequest_EncodingType_RawValue(AnnotateTextRequest *message);
/**
 * Sets the raw value of an @c AnnotateTextRequest's @c encodingType property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetAnnotateTextRequest_EncodingType_RawValue(AnnotateTextRequest *message, int32_t value);

#pragma mark - AnnotateTextRequest_Features

typedef GPB_ENUM(AnnotateTextRequest_Features_FieldNumber) {
  AnnotateTextRequest_Features_FieldNumber_ExtractSyntax = 1,
  AnnotateTextRequest_Features_FieldNumber_ExtractEntities = 2,
  AnnotateTextRequest_Features_FieldNumber_ExtractDocumentSentiment = 3,
};

/**
 * All available features for sentiment, syntax, and semantic analysis.
 * Setting each one to true will enable that specific analysis for the input.
 **/
@interface AnnotateTextRequest_Features : GPBMessage

/** Extract syntax information. */
@property(nonatomic, readwrite) BOOL extractSyntax;

/** Extract entities. */
@property(nonatomic, readwrite) BOOL extractEntities;

/** Extract document-level sentiment. */
@property(nonatomic, readwrite) BOOL extractDocumentSentiment;

@end

#pragma mark - AnnotateTextResponse

typedef GPB_ENUM(AnnotateTextResponse_FieldNumber) {
  AnnotateTextResponse_FieldNumber_SentencesArray = 1,
  AnnotateTextResponse_FieldNumber_TokensArray = 2,
  AnnotateTextResponse_FieldNumber_EntitiesArray = 3,
  AnnotateTextResponse_FieldNumber_DocumentSentiment = 4,
  AnnotateTextResponse_FieldNumber_Language = 5,
};

/**
 * The text annotations response message.
 **/
@interface AnnotateTextResponse : GPBMessage

/**
 * Sentences in the input document. Populated if the user enables
 * [AnnotateTextRequest.Features.extract_syntax][google.cloud.language.v1beta1.AnnotateTextRequest.Features.extract_syntax].
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<Sentence*> *sentencesArray;
/** The number of items in @c sentencesArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger sentencesArray_Count;

/**
 * Tokens, along with their syntactic information, in the input document.
 * Populated if the user enables
 * [AnnotateTextRequest.Features.extract_syntax][google.cloud.language.v1beta1.AnnotateTextRequest.Features.extract_syntax].
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<Token*> *tokensArray;
/** The number of items in @c tokensArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger tokensArray_Count;

/**
 * Entities, along with their semantic information, in the input document.
 * Populated if the user enables
 * [AnnotateTextRequest.Features.extract_entities][google.cloud.language.v1beta1.AnnotateTextRequest.Features.extract_entities].
 **/
@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<Entity*> *entitiesArray;
/** The number of items in @c entitiesArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger entitiesArray_Count;

/**
 * The overall sentiment for the document. Populated if the user enables
 * [AnnotateTextRequest.Features.extract_document_sentiment][google.cloud.language.v1beta1.AnnotateTextRequest.Features.extract_document_sentiment].
 **/
@property(nonatomic, readwrite, strong, null_resettable) Sentiment *documentSentiment;
/** Test to see if @c documentSentiment has been set. */
@property(nonatomic, readwrite) BOOL hasDocumentSentiment;

/**
 * The language of the text, which will be the same as the language specified
 * in the request or, if not specified, the automatically-detected language.
 * See [Document.language][google.cloud.language.v1beta1.Document.language]
 * field for more details.
 **/
@property(nonatomic, readwrite, copy, null_resettable) NSString *language;

@end

NS_ASSUME_NONNULL_END

CF_EXTERN_C_END

#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
